<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Valkan Render Process</title>
  <meta name="description"
    content="Vulkan Render">

  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://huailiang.github.io/blog/2019/cmd/">
  <link rel="alternate" type="application/rss+xml" title="Huailiang Blog"
    href="https://huailiang.github.io/feed.xml" />

</head>

<body>
  <main>
    <header class="site-header">
  <div class="container">
    <h1><a href="/">Hom<span>e</span></a></h1>

    <button type="button" class="sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </button>

    <nav class="navbar sliding-panel-content">
      <ul>
        
        <li><a href="/about" title="About">About</a>
        </li>
        
        <li><a href="/blog" title="Blog">Blog</a>
        </li>
        
        <!-- <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i></a></li> -->
        <li><a href="/category/" target="_blank"><i class="icon icon-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>

<div class="sliding-panel-fade-screen"></div>
    <script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });

</script>
    <div class="container">
      <article role="article" class="post">

  <div class="card">
    <header class="post-header">
      <h1 class="post-title">Valkan Render Process</h1>
      <p class="post-meta">Sep 8, 2019 •
        Huailiang</p>
    </header>

    <div class="post-content">
      <h2 id="vulkan-render">Vulkan Render</h2>

<p>Vulkan 中的重要组件以及它们的工作流程如下图所示，接下来的文章中会针对每个组件进行学习讲解并配上相关的示例代码，首先是 Instance、Device 和 Queue 组件。</p>

<p><img src="/img/post-unity/cmd4.jpeg" alt="" /></p>

<h3 id="instance-组件">Instance 组件</h3>

<p>在开始创建Device等组件之前，需要创建一个VkInstance对象。</p>

<p>通过vkCreateInstance方法创建VKInstance对象，以下是函数原型，在 <vulkan.h> 头文件中。</vulkan.h></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 声明的函数指针的形式
</span><span class="k">typedef</span> <span class="n">VkResult</span> <span class="p">(</span><span class="n">VKAPI_PTR</span> <span class="o">*</span><span class="n">PFN_vkCreateInstance</span><span class="p">)</span>
<span class="p">(</span><span class="k">const</span> <span class="n">VkInstanceCreateInfo</span><span class="o">*</span> <span class="n">pCreateInfo</span><span class="p">,</span> <span class="c1">// 提供创建的信息
</span><span class="k">const</span> <span class="n">VkAllocationCallbacks</span><span class="o">*</span> <span class="n">pAllocator</span><span class="p">,</span> <span class="c1">// 创建时的回调函数
</span><span class="n">VkInstance</span><span class="o">*</span> <span class="n">pInstance</span><span class="p">);</span>                <span class="c1">// 创建的实例
</span></code></pre>
</div>

<p>Queue组件是用来和物理设备沟通的桥梁，而具体的沟通过程就需要Command-Buffer（命令缓冲区）组件，它是若干命令的集合，我们向 Queue提交Command-Buffer，然后才交由物理设备 GPU 进行处理。</p>

<p>在 vkCreateInstance 函数中看到有个名为 VkInstanceCreateInfo 类型的参数，这就是包含了 VKInstance 要创建的信息。</p>

<p>它的参数信息有点多：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkInstanceCreateInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>             <span class="n">sType</span><span class="p">;</span>  <span class="c1">// 一般为方法对应的类型
</span>    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>                 <span class="n">pNext</span><span class="p">;</span> <span class="c1">// 一般为 null 就好了
</span>    <span class="n">VkInstanceCreateFlags</span>       <span class="n">flags</span><span class="p">;</span>  <span class="c1">// 留着以后用的，设为 0 就好了
</span>    <span class="k">const</span> <span class="n">VkApplicationInfo</span><span class="o">*</span>    <span class="n">pApplicationInfo</span><span class="p">;</span> <span class="c1">// 对应新的一个结构体 VkApplicationInfo
</span>    <span class="kt">uint32_t</span>                    <span class="n">enabledLayerCount</span><span class="p">;</span> <span class="c1">// layer 和 extension 用于调试和拓展
</span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span>          <span class="n">ppEnabledLayerNames</span><span class="p">;</span>
    <span class="kt">uint32_t</span>                    <span class="n">enabledExtensionCount</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span>          <span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkInstanceCreateInfo</span><span class="p">;</span>
</code></pre>
</div>

<p>除了还需要创建一个VkApplicationInfo对象，还可以设置Layer和Extension。<br />
其中：Layer 是用来错误校验、调试输出的。为了提供性能，其中的方法之一就是减少驱动进行状态、错误校验，而 Vulkan 就把这一层单独抽出来了。</p>

<p><img src="/img/post-unity/cmd3.jpg" alt="" /></p>

<p>Layer 在整个架构中的位置如上图，Vulkan API 直接和驱动对话，而 Layer 处于应用和 Vulkan API 之间，供开发者进行调试。</p>

<p>另外，Extension 就是 Vulkan 支持的拓展，最典型的就是 Vulkan 的跨平台渲染显示，就是通过拓展来完成的，比如在 Android、Windows 上使用 Vulkan 都需要使用不同的拓展才可以把内容显示到屏幕上。</p>

<p>VkApplicationInfo 结构体，也是创建 Instance 的必要参数之一</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkApplicationInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>    <span class="n">sType</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>        <span class="n">pNext</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span>        <span class="n">pApplicationName</span><span class="p">;</span>
    <span class="kt">uint32_t</span>           <span class="n">applicationVersion</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span>        <span class="n">pEngineName</span><span class="p">;</span>
    <span class="kt">uint32_t</span>           <span class="n">engineVersion</span><span class="p">;</span>
    <span class="kt">uint32_t</span>           <span class="n">apiVersion</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkApplicationInfo</span><span class="p">;</span>
</code></pre>
</div>

<p>参数释义就比较容易理解了，设置应用的名称、版本号等，有了它们就可以创建 Instance 对象了 。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">VkApplicationInfo</span> <span class="n">app_info</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">app_info</span><span class="p">.</span><span class="n">apiVersion</span> <span class="o">=</span> <span class="n">VK_API_VERSION_1_0</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">applicationVersion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">engineVersion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_APPLICATION_INFO</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">pEngineName</span> <span class="o">=</span> <span class="n">APPLICATION_NAME</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">pApplicationName</span> <span class="o">=</span> <span class="n">APPLICATION_NAME</span><span class="p">;</span>

<span class="n">VkInstanceCreateInfo</span> <span class="n">instance_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// type 就是结构体的类型
</span><span class="n">instance_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">pApplicationInfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">app_info</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// Extension and Layer 暂时不用,可空
</span><span class="n">instance_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">enabledLayerCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkCreateInstance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance_info</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="p">);</span>
</code></pre>
</div>

<p>当每调用一个创建函数后，返回的类型都是VkResult，只要VkResult大于0，那么执行就是成功的。</p>

<p>另外还有个参数是 VkAllocationCallbacks，表示函数调用时的回调，需要传递一个函数指针，在后面的各种调用中都会看到它的身影，如果有用到可以传参，一般为nullptr就好了。</p>

<p>关于每个结构体，它每个参数的具体释义，参考<a href="https://www.khronos.org/registry/vulkan/specs/1.0/pdf/vkspec.pdf">vkspec.pdf</a> ，里面有对每个参数、结构体的详细释义。</p>

<h2 id="device-组件">Device 组件</h2>

<p>有了Instance组件，就可以创建Device组件了，按照调用的套路，肯定还会有一个VkDeviceCreateInfo的结构体表示Device的创建信息。而Device具体指的是逻辑上的设备，可以说是对物理设备的一个逻辑上的封装，而物理设备就是VkPhysicalDevice对象。在某些情况下，可能会具有多个物理设备，如下图所示，因此要先枚举一下所有的物理设备：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">LOGI</span><span class="p">(</span><span class="s">"enumerate gpu device"</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">gpu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// 第一次调用只为了获得个数
</span><span class="n">VkResult</span> <span class="n">res</span> <span class="o">=</span> <span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpu_size</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
</code></pre>
</div>

<p>在 vkEnumeratePhysicalDevices 方法中，传入的第二个参数为 gpu 的个数，第三个参数为 null，这样的一次调用会返回 gpu 的个数到 gpu_size 变量。</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span> <span class="n">gpus</span><span class="p">;</span>
<span class="n">gpus</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">gpu_size</span><span class="p">);</span>
<span class="c1">// vector.data() 方法转换成指针类型
// 第二次调用获得所有的数据
</span><span class="n">res</span> <span class="o">=</span> <span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpu_size</span><span class="p">,</span> <span class="n">gpus</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</code></pre>
</div>
<p>当再一次调用vkEnumeratePhysicalDevices函数时，第三个参数不为null，而是相应的VkPhysicalDevice容器，那么gpus会填充 gpu_size个的VkPhysicalDevice对象。</p>

<p>这也算是Vulkan API调用的一个固定套路了，调用两次来获得数据，在后面的代码中也会经常看到这种方式。有了VkPhysicalDevice对象之后，可以查询VkPhysicalDevice上的一些属性，以下函数都可以查询相关信息：</p>

<ul>
  <li>vkGetPhysicalDeviceQueueFamilyProperties</li>
  <li>vkGetPhysicalDeviceMemoryProperties</li>
  <li>vkGetPhysicalDeviceProperties</li>
  <li>vkGetPhysicalDeviceImageFormatProperties</li>
  <li>vkGetPhysicalDeviceFormatProperties</li>
</ul>

<p>在这里需要用到的属性是QueueFamilyProperties ，获得该属性的方法调用方式和获得 VkPhysicalDevice 数据方式一样，也是一个两次调用。如果有设备有多个GPU，那么这里取第一个来获取它的相关属性：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 第一次调用，获得个数
</span><span class="kt">uint32_t</span> <span class="n">queue_family_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">queue_family_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// 第二次调用，获得实际数据
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkQueueFamilyProperties</span><span class="o">&gt;</span> <span class="n">queue_family_props</span><span class="p">;</span>
<span class="n">queue_family_props</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">queue_family_count</span><span class="p">);</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span> <span class="n">queue_family_props</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">assert</span><span class="p">(</span><span class="n">queue_family_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre>
</div>

<p>QueueFamilyProperties 的结构体含义如下：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkQueueFamilyProperties</span> <span class="p">{</span>
    <span class="n">VkQueueFlags</span>    <span class="n">queueFlags</span><span class="p">;</span>      <span class="c1">// 标识位：表示 Queue 的功能
</span>    <span class="kt">uint32_t</span>        <span class="n">queueCount</span><span class="p">;</span>         
    <span class="kt">uint32_t</span>        <span class="n">timestampValidBits</span><span class="p">;</span>
    <span class="n">VkExtent3D</span>      <span class="n">minImageTransferGranularity</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkQueueFamilyProperties</span><span class="p">;</span>
</code></pre>
</div>

<p>其中：queueFlags 表示该 Queue 的能力，有的 Queue 是用来渲染图像的，这个和我们的使用最为密切，还有的 Queue 是用来计算的。</p>

<p>具体的 Flag 标识如下：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkQueueFlagBits</span> <span class="p">{</span>
    <span class="n">VK_QUEUE_GRAPHICS_BIT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>         <span class="c1">// 图像相关
</span>    <span class="n">VK_QUEUE_COMPUTE_BIT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>          <span class="c1">// 计算相关
</span>    <span class="n">VK_QUEUE_TRANSFER_BIT</span> <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
    <span class="n">VK_QUEUE_SPARSE_BINDING_BIT</span> <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>
    <span class="n">VK_QUEUE_FLAG_BITS_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkQueueFlagBits</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">VkFlags</span> <span class="n">VkQueueFlags</span><span class="p">;</span>
</code></pre>
</div>

<p>一般来说，我们用的是queueFlags为VK_QUEUE_GRAPHICS_BIT标识位的Queue。那么Queue究竟是什么？物理设备可能会有多个 Queue，不同的 Queue 对应不同的特性。</p>

<p>在文章最开始的图中可以看到，Command-buffer是提交到了Queue，Queue再提交给Device去执行。Queue可以看成是应用程序和物理设备沟通的桥梁，我们在Queue上提交命令，然后再交由GPU去执行。</p>

<h2 id="device-组件-1">Device 组件</h2>

<p>创建一个Device对象，不仅需要指定具体的物理设备VkPhysicalDevice，另外还需要该物理设备上的 Queue 相关信息。在VkDeviceCreateInfo结构体中需要一个参数是 VkDeviceQueueCreateInfo ，它的创建如下：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Queue 所需的相关信息
</span><span class="n">VkDeviceQueueCreateInfo</span> <span class="n">queue_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 找到属性为 VK_QUEUE_GRAPHICS_BIT 的索引
</span><span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue_family_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_family_props</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queueFlags</span> <span class="o">&amp;</span> <span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">queue_priorities</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">};</span>
<span class="c1">// 结构体的类型
</span><span class="n">queue_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span><span class="p">;</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">queueCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// Queue 的优先级
</span><span class="n">queue_info</span><span class="p">.</span><span class="n">pQueuePriorities</span> <span class="o">=</span> <span class="n">queue_priorities</span><span class="p">;</span>
</code></pre>
</div>

<p>接下来就可以完成 Queue 的创建：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Device 所需的相关信息类
</span><span class="n">VkDeviceCreateInfo</span> <span class="n">device_info</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">device_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="c1">// Device 所需的 Queue 相关信息
</span><span class="n">device_info</span><span class="p">.</span><span class="n">queueCreateInfoCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// Queue 个数
</span><span class="n">device_info</span><span class="p">.</span><span class="n">pQueueCreateInfos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue_info</span><span class="p">;</span>    <span class="c1">// Queue 相关信息
// Layer 和 Extension 暂时为空，不影响运行，后续再补上
</span><span class="n">device_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">enabledLayerCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">pEnabledFeatures</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateDevice</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">device_info</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="queue-组件">Queue 组件</h2>

<p>完成了 Device 创建之后，Queue 的创建也简单多了，直接调用如下函数就好了：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">VKAPI_PTR</span> <span class="o">*</span><span class="n">PFN_vkGetDeviceQueue</span><span class="p">)</span>
<span class="p">(</span><span class="n">VkDevice</span> <span class="n">device</span><span class="p">,</span>   <span class="c1">// 创建的 Device 对象
</span><span class="kt">uint32_t</span> <span class="n">queueFamilyIndex</span><span class="p">,</span> <span class="c1">// queueFlags 为 VK_QUEUE_GRAPHICS_BIT 的索引
</span><span class="kt">uint32_t</span> <span class="n">queueIndex</span><span class="p">,</span>        
<span class="n">VkQueue</span><span class="o">*</span> <span class="n">pQueue</span><span class="p">);</span>       <span class="c1">// 要创建的 Queue
</span>
<span class="c1">// 代码示例
</span><span class="n">vkGetDeviceQueue</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
</code></pre>
</div>
<p>组件销毁</p>

<p>完成了 Instance、Device、Queue 组件的创建之后，还有一件要做的事情就是释放它们，销毁组件。</p>

<p>按照先进后出的方式进行销毁，Instance 最先创建反而最后销毁，和 Device 相关联的 Queue 当 Device 销毁了，Queue 也随之销毁了。</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 销毁 Device
</span><span class="n">vkDestroyDevice</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="c1">// 销毁 Instance
</span><span class="n">vkDestroyInstance</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="vulkan-commandbuffer">Vulkan Commandbuffer</h2>

<h3 id="command-pool-组件">Command-Pool 组件</h3>

<p>在创建 Command-Buffer之前，需要创建 Command-Pool 组件，从Command-Pool中去分配 Command-Buffer. 先创建一个 VkXXXXCreateInfo 的结构体</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Command-Pool 组件
</span><span class="n">VkCommandPool</span> <span class="n">command_pool</span><span class="p">;</span>
<span class="n">VkCommandPoolCreateInfo</span> <span class="n">poolCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">poolCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</span><span class="p">;</span>
<span class="c1">// 可以看到 Command-Pool 还和 Queue 相关联
</span><span class="n">poolCreateInfo</span><span class="p">.</span><span class="n">queueFamilyIndex</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span><span class="p">;</span>
<span class="c1">// 标识命令缓冲区的一些行为
</span><span class="n">poolCreateInfo</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span><span class="p">;</span>
<span class="c1">// 具体创建函数的调用
</span><span class="n">vkCreateCommandPool</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poolCreateInfo</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command_pool</span><span class="p">);</span>

</code></pre>
</div>

<p>有几个参数需要注意：</p>

<ol>
  <li>queueFamilyIndex 参数为创建 Queue 时选择的那个 queueFlags 为 VK_QUEUE_GRAPHICS_BIT 的索引，从 Command-Pool 中分配的的 Command-Buffer 必须提交到同一个 Queue 中。</li>
  <li>flags 有如下的选项，分别指定了 Command-Buffer 的不同特性：</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkCommandPoolCreateFlagBits</span> <span class="p">{</span>
    <span class="n">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
    <span class="n">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
    <span class="n">VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkCommandPoolCreateFlagBits</span><span class="p">;</span>
</code></pre>
</div>

<ul>
  <li>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</li>
</ul>

<p>表示该 Command-Buffer 的寿命很短，可能在短时间内被重置或释放</p>

<ul>
  <li>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</li>
</ul>

<p>表示从 Command-Pool 中分配的 Command-Buffer 可以通过 vkResetCommandBuffer 或者 vkBeginCommandBuffer 方法进行重置，如果没有设置该标识位，就不能调用 vkResetCommandBuffer 方法进行重置。</p>

<h3 id="command-buffer-组件">Command-Buffer 组件</h3>

<p>接下来就是从 Command-Pool 中分配 Command-Buffer，通过 VkCommandBufferAllocateInfo 函数。</p>

<p>首先需要一个 VkCommandBufferAllocateInfo 结构体表示分配所需要的信息。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkCommandBufferAllocateInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>         <span class="n">sType</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>             <span class="n">pNext</span><span class="p">;</span>
    <span class="n">VkCommandPool</span>           <span class="n">commandPool</span><span class="p">;</span>    <span class="c1">// 对应上面创建的 command-pool
</span>    <span class="n">VkCommandBufferLevel</span>    <span class="n">level</span><span class="p">;</span>
    <span class="kt">uint32_t</span>                <span class="n">commandBufferCount</span><span class="p">;</span> <span class="c1">// 创建的个数
</span><span class="p">}</span> <span class="n">VkCommandBufferAllocateInfo</span><span class="p">;</span>
</code></pre>
</div>

<p>其中VkCommandBufferLevel 指定 Command-Buffer 的级别。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkCommandBufferLevel</span> <span class="p">{</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_END_RANGE</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="n">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span> <span class="o">-</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkCommandBufferLevel</span><span class="p">;</span>

</code></pre>
</div>
<p>一般来说，使用 VK_COMMAND_BUFFER_LEVEL_PRIMARY 就好了。</p>

<p>具体创建代码如下：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">VkCommandBuffer</span> <span class="n">commandBuffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">VkCommandBufferAllocateInfo</span> <span class="n">command_buffer_allocate_info</span><span class="p">{};</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">commandPool</span> <span class="o">=</span> <span class="n">command_pool</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">commandBufferCount</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span><span class="p">;</span>
<span class="n">vkAllocateCommandBuffers</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command_buffer_allocate_info</span><span class="p">,</span> <span class="n">commandBuffer</span><span class="p">);</span>
</code></pre>
</div>
<h3 id="command-buffer-的生命周期">Command-Buffer 的生命周期</h3>

<p>创建了 Command-Buffer 之后，它的生命周期，如下图：</p>

<p><img src="/img/post-unity/cmd5.jpeg" alt="" /></p>

<ul>
  <li>
    <p>Initial 状态<br />
在 Command-Buffer 刚刚创建时，它就是处于初始化的状态。从此状态，可以达到 Recording 状态，另外，如果重置之后，也会回到该状态。</p>
  </li>
  <li>
    <p>Recording 状态<br />
调用 vkBeginCommandBuffer 方法从 Initial 状态进入到该状态。一旦进入该状态后，就可以调用 vkCmd* 等系列方法记录命令。</p>
  </li>
  <li>
    <p>Executable 状态<br />
调用 vkEndCommandBuffer 方法从 Recording 状态进入到该状态，此状态下，Command-Buffer 可以提交或者重置。</p>
  </li>
  <li>
    <p>Pending 状态<br />
把 Command-Buffer 提交到 Queue 之后，就会进入到该状态。此状态下，物理设备可能正在处理记录的命令，因此不要在此时更改 Command-Buffer，当处理结束后，Command-Buffer 可能会回到 Executable 状态或者 Invalid 状态。</p>
  </li>
  <li>
    <p>Invalid 状态<br />
一些操作会使得 Command-Buffer 进入到此状态，该状态下，Command-Buffer 只能重置、或者释放。</p>
  </li>
</ul>

<h3 id="command-buffer-的记录与提交">Command-Buffer 的记录与提交</h3>

<p>现在可以尝试着记录一些命令，提交到 Queue 上了，命令记录的调用过程如下图：</p>

<p><img src="/img/post-unity/cmd6.jpeg" alt="" /></p>

<p>在 vkBeginCommandBuffer 和 vkEndCommandBuffer 方法之间可以记录和渲染相关的命令，这里先不考虑中间的过程，直接创建提交。</p>

<h4 id="begin-阶段">begin 阶段</h4>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">VkCommandBufferBeginInfo</span> <span class="n">beginInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">beginInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</span><span class="p">;</span>
<span class="n">beginInfo</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span><span class="p">;</span>
<span class="n">vkBeginCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">beginInfo</span><span class="p">);</span>
</code></pre>
</div>

<p>首先，还是需要创建一个 VkCommandBufferBeginInfo 结构体用来表示 Command-Buffer 开始的信息。<br />
这里要注意的参数是 flags ，表示 Command-Buffer 的用途，</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkCommandBufferUsageFlagBits</span> <span class="p">{</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</span> <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkCommandBufferUsageFlagBits</span><span class="p">;</span>
</code></pre>
</div>

<ul>
  <li>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT<br />
表示该 Command-Buffer 只使用提交一次，用完之后就会被重置，并且每次提交时都需要重新记录</li>
</ul>

<h4 id="end-阶段">end 阶段</h4>

<p>直接调用 vkEndCommandBuffer 方法就可以结束记录，此时就可以提交了。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">vkEndCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre>
</div>

<h3 id="buffer-提交">buffer 提交</h3>

<p>通过 vkQueueSubmit 方法将 Command-Buffer 提交到 Queue 上。</p>

<p>同样的还是需要创建一个 VkSubmitInfo 结构体：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkSubmitInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>                <span class="n">sType</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>                    <span class="n">pNext</span><span class="p">;</span>
    <span class="kt">uint32_t</span>                       <span class="n">waitSemaphoreCount</span><span class="p">;</span>  <span class="c1">// 等待的 Semaphore 数量
</span>    <span class="k">const</span> <span class="n">VkSemaphore</span><span class="o">*</span>             <span class="n">pWaitSemaphores</span><span class="p">;</span>     <span class="c1">// 等待的 Semaphore 数组指针
</span>    <span class="k">const</span> <span class="n">VkPipelineStageFlags</span><span class="o">*</span>    <span class="n">pWaitDstStageMask</span><span class="p">;</span>       <span class="c1">// 在哪个阶段进行等待
</span>    <span class="kt">uint32_t</span>                       <span class="n">commandBufferCount</span><span class="p">;</span>  <span class="c1">// 提交的 Command-Buffer 数量
</span>    <span class="k">const</span> <span class="n">VkCommandBuffer</span><span class="o">*</span>         <span class="n">pCommandBuffers</span><span class="p">;</span>      <span class="c1">// 具体的 Command-Buffer 数组指针
</span>    <span class="kt">uint32_t</span>                       <span class="n">signalSemaphoreCount</span><span class="p">;</span>    <span class="c1">//执行结束后通知的 Semaphore 数量
</span>    <span class="k">const</span> <span class="n">VkSemaphore</span><span class="o">*</span>             <span class="n">pSignalSemaphores</span><span class="p">;</span>       <span class="c1">//执行结束后通知的 Semaphore 数组指针
</span><span class="p">}</span> <span class="n">VkSubmitInfo</span><span class="p">;</span>
</code></pre>
</div>
<p>它的参数比较多，并且涉及到 Command-Buffer 之间的同步关系了，这里简单说一下，后面再细说这一块。</p>

<p>如下图，Vulkan 中有 Semaphore、Fences、Event、Barrier 四种机制来保证同步。</p>

<p><img src="/img/post-unity/cmd7.jpeg" alt="" /></p>

<h3 id="semaphore-和-fence">Semaphore 和 Fence</h3>

<h4 id="semaphore">Semaphore</h4>

<p>Semaphore 的作用主要是用来向 Queue 中提交 Command-Buffer 时实现同步。比如说某个 Command-Buffer-B 在执行的某个阶段中需要等待另一个 Command-Buffer-A 执行成功后的结果，同时 Command-Buffer-C 在某阶段又要要等待 Command-Buffer-B 的执行结果，那么就应该使用 Semaphore 机制实现同步；<br />
此时 Command-Buffer-B 提交到 Queue 时就需要两个 VkSemaphor ，一个表示它需要等待的 Semaphore，并且指定在哪个阶段等待；一个是它执行结束后发出通知的 Semaphore。</p>

<h4 id="fence">Fence</h4>

<p>Fence 的作用主要是用来保证物理设备和应用程序之间的同步，比如说向 Queue 中提交了 Command-Buffer 后，具体的执行交由物理设备去完成了，这是一个异步的过程，而应用程序如果要等待执行结束，就要使用 Fence 机制。<br />
Semaphore 和 Fence 有相同之处，但是使用场景却不一样，就如图所示。</p>

<p>Semaphore 和 Fence 的创建过程如下，和以往的 Vulkan 创建对象的调用方式没有太大区别：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Semaphore
</span><span class="n">VkSemaphore</span> <span class="n">imageAcquiredSemaphore</span><span class="p">;</span>
<span class="n">VkSemaphoreCreateInfo</span> <span class="n">semaphoreCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">semaphoreCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</span><span class="p">;</span>
<span class="n">vkCreateSemaphore</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semaphoreCreateInfo</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imageAcquiredSemaphore</span><span class="p">);</span>

<span class="c1">// 创建 Fence
</span><span class="n">VkFence</span> <span class="n">drawFence</span><span class="p">;</span>
<span class="n">VkFenceCreateInfo</span> <span class="n">fenceCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">fenceCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</span><span class="p">;</span>
<span class="c1">// 该参数表示 Fence 的状态，如果不设置或者为 0 表示 unsignaled state
</span><span class="n">fence_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
<span class="n">vkCreateFence</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenceCreateInfo</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drawFence</span><span class="p">);</span>
</code></pre>
</div>

<p>继续回到 VkSubmitInfo 结构体中，如果只是简单的提交 Command-Buffer，那就不需要考虑 Semaphore 这些同步机制了，把相应的参数都设置为 nullptr，或者直接不设置也行，最后提交就好了，代码如下:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 简单的提交过程
// 开始记录
</span><span class="n">VkCommandBufferBeginInfo</span> <span class="n">beginInfo1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">beginInfo1</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</span><span class="p">;</span>
<span class="n">beginInfo1</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span><span class="p">;</span>
<span class="n">vkBeginCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">beginInfo1</span><span class="p">);</span>

<span class="c1">// 省略中间的 vkCmdXXXX 系列方法
// 结束记录
</span><span class="n">vkEndCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">VkSubmitInfo</span> <span class="n">submitInfo1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">submitInfo1</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_SUBMIT_INFO</span><span class="p">;</span>
<span class="c1">// pWaitSemaphores 和 pSignalSemaphores 都不设置，只是提交
</span><span class="n">submitInfo1</span><span class="p">.</span><span class="n">commandBufferCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">submitInfo1</span><span class="p">.</span><span class="n">pCommandBuffers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// 注意最后的参数 临时设置为 VK_NULL_HANDLE，也可以设置为  Fence 来同步
</span><span class="n">vkQueueSubmit</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">submitInfo1</span><span class="p">,</span> <span class="n">VK_NULL_HANDLE</span><span class="p">);</span>
</code></pre>
</div>

<p>以上就完成了 Command-Buffer 提交到 Queue 的过程，省略了 Semaphores 和 Fences 的同步机制，当然也可以把它们加上。</p>

<p>在 vkQueueSubmit 的最后一个参数设置为了 VK_NULL_HANDLE ，这是 Vulkan 中设置为 NULL 的一个方法（其实是设置了一个整数 0 ），也可以设置了 Fence ，表示我们要等待该 Command-Buffer 在 Queue 执行结束，虽说 Command-Buffer 也可以通过 Semaphore 来表示执行结束，但这两种方式的使用场景不一样。</p>

<p>回到 Fence 的创建过程，其中有一个 flags 参数表示 Fence 的状态，有如下两种状态：</p>

<ul>
  <li>signaled state<br />
如果 flags 参数为 VK_FENCE_CREATE_SIGNALED_BIT 则表示创建后处于该状态。</li>
  <li>unsignaled state<br />
默认的状态。<br />
当 vkQueueSubmit 的最后参数传入 Fence 后，就可以通过 Fence 等待该 Command-Buffer 执行结束。</li>
</ul>

<p>当 vkQueueSubmit 的最后参数传入 Fence 后，就可以通过 Fence 等待该 Command-Buffer 执行结束。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// wait fence to enter the signaled state on the host
//  错误的 waitForFences 使用，因为它并不是一个阻塞的方法
//  VkResult res = vkWaitForFences(info.device, 1, &amp;fence, VK_TRUE, UINT64_MAX);
</span>    <span class="n">VkResult</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">vkWaitForFences</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fence</span><span class="p">,</span> <span class="n">VK_TRUE</span><span class="p">,</span> <span class="n">UINT64_MAX</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_TIMEOUT</span><span class="p">);</span>
</code></pre>
</div>

<p>vkWaitForFences 方法会等待 Fence 进入 signaled state 状态，该方法的调用要放在 while 循环中，因为它并不是一个阻塞的方法，可以理解成一个状态查询，如果结果不对，返回的是 VK_TIMEOUT，结果满足要求才返回 VK_SUCCESS 。</p>

<p>当  Command-Buffer 执行结束后，传入的 Fence 参数就会从 unsignaled state 进入到 signaled state ，从而触发 vkWaitForFences 调用结束循环，表明执行结束了。</p>

<p><br /><br />
参考链接:<br />
 <a href="https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html">Unity Command buffer API</a><br />
 <a href="https://www.jianshu.com/p/9ee2adb26969">Vulkan 移动开发之 Command Buffer</a><br />
 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/pdf/vkspec.pdf">vkspec.pdf</a></p>


    </div>
  </div>

  <style>
  .post-nav {
    overflow: hidden;
    /* margin-top: 60px; */
    padding: 12px;
    white-space: nowrap;
    /* border-top: 1px solid #eee; */
  }

  .post-nav-item {
    display: inline-block;
    width: 50%;
    white-space: normal;
  }

  .post-nav-item a {
    position: relative;
    display: inline-block;
    line-height: 25px;
    font-size: 14px;
    color: #555;
    border-bottom: none;
  }

  .post-nav-item a:hover {
    color: #222;
    font-weight: bold;
    border-bottom: none;
  }

  .post-nav-item a:active {
    top: 2px;
  }

  .post-nav-item a:before,
  .post-nav-item a:after {
    display: inline-block;
    width: 16px;
    height: 25px;
    vertical-align: top;
    opacity: 0.4;
    background-size: 16px;
  }

  .post-nav-none a:none {
    content: ' ';
    background-size: 8px;
  }

  .post-nav-none a:hover:none {
    opacity: 1;
  }

  .post-nav-prev a:before {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjE4LjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLWxlZnQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxOC41MDAwMDAsIDkwLjAwMDAwMCkiPjxwYXRoIGQ9Ik03LjQsMS40IEw2LDAgTC04Ljg4MTc4NDJlLTE2LDYgTDYsMTIgTDcuNCwxMC42IEwyLjgsNiBMNy40LDEuNCBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=") no-repeat 0 50%;
    background-size: 8px;
  }

  .post-nav-prev a:hover:before {
    opacity: 1;
  }

  .post-nav-next {
    text-align: right;
  }

  .post-nav-next a:after {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjYwLjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLXJpZ2h0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNjAuNTAwMDAwLCA5MC4wMDAwMDApIj48cGF0aCBkPSJNMSwwIEwtMC40LDEuNCBMNC4yLDYgTC0wLjQsMTAuNiBMMSwxMiBMNyw2IEwxLDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+") no-repeat 100% 50%;
    background-size: 8px;
  }

  .post-nav-next a:hover:after {
    opacity: 1;
  }
</style>



<div class="post-nav">

  
  <div class="post-nav-none post-nav-item">
    <a href=""> </a>
  </div>
  

  
  <div class="post-nav-next post-nav-item">
    
    <a href="/blog/2019/texturearray/"> TextureArray用法</a>
  </div>
  

</div>

</article>
    </div>

    <footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="https://twitter.com/penghuailiang" target="_blank"><i class="icon icon-twitter"></i></a></li>
  <li><a href="https://www.zhihu.com/people/huailiangpenguin" target="_blank"><i class="icon icon-zhihu"></i></a></li>
  <li><a href="https://www.facebook.com/profile.php?id=100004290725320" target="_blank"><i class="icon icon-facebook"></i></a></li>
  <li><a href="https://weibo.com/6212299692/profile?topnav=1&wvr=6" target="_blank"><i class="icon icon-sina"></i></a></li>
  <li><a href="https://www.linkedin.com/in/penghuailiang/" target="_blank"><i class="icon icon-linkedin"></i></a></li>
  <li><a href="https://github.com/huailiang" target="_blank"><i class="icon icon-github"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>&copy;2019 All rights reserved. </small>
    </p>
  </div>
</footer>
    <a href="https://github.com/huailiang" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#337ab7; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
    <script>
      $(document).ready(function () {
        $('.sliding-panel-button,.sliding-panel-fade-screen,.sliding-panel-close').on('click touchstart', function (e) {
          $('.sliding-panel-content,.sliding-panel-fade-screen').toggleClass('is-visible');
          e.preventDefault();
        });
      });
    </script>
  </main>
</body>

</html>