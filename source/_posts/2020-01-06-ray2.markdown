---
layout:     post
title:      "光线追踪-降噪"
date:       2020-01-06 03:00:00
author:     "Huailiang"
tags:
    - 引擎
---

>图像去噪是非常基础也是非常必要的研究，去噪常常在更高级的图像处理之前进行，是图像处理的基础。可惜的是，目前去噪算法并没有很好的解决方案，实际应用中，更多的是在效果和运算复杂度之间求得一个平衡。

### 噪声模型

图像中噪声的来源有许多种，这些噪声来源于图像采集、传输、压缩等各个方面。噪声的种类也各不相同，比如椒盐噪声，高斯噪声等，针对不同的噪声有不同的处理算法。

对于输入的带有噪声的图像v(x)，其加性噪声可以用一个方程来表示：

$$
v(x) = u(x) + \eta (x),\quad x \in \Omega ,
$$

其中u(x)是原来没有噪声的图像。x是像素集合，η(x)是加项噪声项，代表噪声带来的影响。Ω是像素的集合，也就是整幅图像。从这个公式可以看出，噪声是直接叠加在原始图像上的，这个噪声可以是椒盐噪声、高斯噪声。理论上来说，如果能够精确地获得噪声，用输入图像减去噪声就可以恢复出原始图像。但现实往往很骨感，除非明确地知道噪声生成的方式，否则噪声很难单独求出来。

工程上，图像中的噪声常常用高斯噪声$N(μ,σ^2)$来近似表示，其中$μ=0，σ^2$是噪声的方差，$σ^2$越大，噪声越大。一个有效的去除高斯噪声的方式是图像求平均，对N幅相同的图像求平均的结果将使得高斯噪声的方差降低到原来的N分之一，现在效果比较好的去噪算法都是基于这一思想来进行算法设计。

<iframe src="//player.bilibili.com/player.html?aid=29458366&cid=51215573&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"  width="700" height="460"> </iframe>

### 为什么光线追踪会出现噪点

因为光线追踪，确切地说是路径追踪(Path Tracing)本质上是在解渲染方程，一个积分方程。

$$ L(x, \, \vec \omega_{o}) = L_e(x, \, \vec \omega_{o}) + \int_{\Omega}{f_r(x, \, \vec \omega_{i}, \, \vec \omega_{o}) \, (\vec \omega_{i} \cdot \vec n) \, L(x, \, \vec \omega_{i}) \, d\vec \omega_{i}} 
$$

使用蒙特卡洛采样， 将上面积分式转换为离散的表达式:

$$
L(x, \, \vec \omega_{o}) \approx L_e(x, \, \vec \omega_{o}) + \frac{1}{N} \sum_{n=0}^{N}{2 \pi \, f_r(x, \, \vec \omega_{i}, \, \vec \omega_{o}) \, (\vec \omega_{i} \cdot \vec n) \, L(x, \, \vec \omega_{i})}
$$

当然，引入这个方法，如果采样数量不够多，会造成光照贡献量与实际值偏差依然会很大，形成噪点（即上式中N比较小）。随着采样数量的增加，局部估算越来越接近实际光照积分，噪点逐渐消失（下图）。

![](/img/post-ml/ray1.jpg)

从左到右分别对应的每个象素采样为1、16、256、4096、65536


## 峰值信噪比

PSNR是*Peak Signal to Noise Ratio*的缩写，即峰值信噪比，是一种评价图像的客观标准，它具有局限性，一般是用于最大值信号和背景噪音之间的一个工程项目。

psnr一般是用于最大值信号和背景噪音之间的一个工程项目。通常在经过影像压缩之后，输出的影像都会在某种程度与原始影像不同。为了衡量经过处理后的影像品质，我们通常会参考PSNR值来衡量某个处理程序能否令人满意。它是原图像与被处理图像之间的均方误差相对于$(2^n-1)^2$的对数值(信号最大值的平方，n是每个采样值的比特数)，它的单位是dB。 

给定一个大小为 m×n 的干净图像 I 和噪声图像 K，均方误差 (MSE) 定义为：

$$
MSE = \frac{1}{mn}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1}[I(i, j)-K(i,j)]^2
$$

数学公式如下：

$$
PSNR = 10 \cdot log_{10}(\frac{(2^n-1)^2}{MSE})
$$

一般地，针对 uint8 数据，最大像素值为 255,；针对浮点型数据，最大像素值为 1。n为每像素的比特数，一般取8，即像素灰阶数为256. PSNR的单位是dB，数值越大表示失真越小。

上面是针对灰度图像的计算方法，如果是彩色图像，通常有三种方法来计算。
* 分别计算 RGB 三个通道的 PSNR，然后取平均值。
* 计算 RGB 三通道的 MSE ，然后再除以 3 。
* 将图片转化为 YCbCr 格式，然后只计算 Y 分量也就是亮度分量的 PSNR。

```py
# im1 和 im2 都为灰度图像，uint8 类型

# method 1
diff = im1 - im2
mse = np.mean(np.square(diff))
psnr = 10 * np.log10(255 * 255 / mse)

# method 2
psnr = skimage.measure.compare_psnr(im1, im2, 255)
```

### 数据集

可以使用[Tungsten][i7]引擎来生成， 也可以去开源的站点去[下载][i8]。 下面主要介绍使用引擎生成数据集的方式。

Tungsten是一个基于物理的渲染器，最初为ETH年的年度渲染竞赛编写。 它通过对渲染方程的无偏积分来模拟通过任意几何的全光传输。 Tungsten支持各种光传输算法，如双向路径跟踪BRDF、渐进光子映射、空间城市光传输等。Tungsten是用C++11编写的，利用了几何交叉库embree的高性能。 Tungsten充分利用多核系统，并通过频繁的基准和优化来提供良好的性能。 运行渲染器至少需要SSE3支持。

![](/img/post-ml/ray3.jpg)

编译生成引擎， 需要你本地已经安装了GCC， 下载然后make:

```sh
git clone https://github.com/tunabrain/tungsten.git
./setup_builds.sh
cd build/release
make
```

然后添加Tungsten 到环境变量PATH里去，（Mac系统保存环境变量在.profle文件)

```sh
echo 'export PATH="<tungsten-release-dir>":$PATH' >> ~/.bashrc
source ~/.bashrc
```

在终端里敲命令，看是否配置成功：

```sh
tungsten -v
```

下载场景贴图(大概860张建筑贴图)：

```sh
cd data && mkdir scenes
wget https://benedikt-bitterli.me/resources/tungsten/bathroom.zip
unzip bathroom.zip -d scenes
rm *.zip
```

[render.py][i2]生成训练集：
```py
python3 render.py \
  --scene-path ../data/scenes/bathroom/scene.json \
  --spp 8 \
  --nb-renders 48 \
  --output-dir ../data/mc/train \
  --hdr-targets
```

Tungsten生成的mc-noised 和cleaned 图像对比：

![](/img/post-ml/ray4.jpg)

Unity 生成的mc-noised 和 cleaned的图像对比：

![](/img/post-ml/ray5.jpg)

## NL-Means算法

NL-Means的全称是：Non-Local Means，直译过来是非局部平均，在2005年由Baudes提出，该算法使用自然图像中普遍存在的冗余信息来去噪声。与常用的双线性滤波、中值滤波等利用图像局部信息来滤波不同的是，它利用了整幅图像来进行去噪，以图像块为单位在图像中寻找相似区域，再对这些区域求平均，能够比较好地去掉图像中存在的高斯噪声。NL-Means的滤波过程可以用下面公式来表示：

$$
\tilde u(x) = \sum\limits_{y \in {\Omega _x}} {w(x,y)v(y)}.
$$

在这个公式中，w(x,y)是一个权重，表示在原始图像v中，像素 x 和像素 y 的相似度。这个权重要大于0，同时，权重的和为1，用公式表示是这样：

$$
w(x,y) > 0\quad and\quad \sum\limits_{y \in {\Omega _x}} {w(x,y) = 1}, \quad \forall x \in \Omega ,y \in {\Omega _x} .
$$

Ωx是像素 x 的邻域。这个公式可以这样理解：对于图像中的每一个像素 x ，去噪之后的结果等于它邻域中像素 y 的加权和，加权的权重等于 x 和 y 的相似度。这个邻域也称为搜索区域，搜索区域越大，找到相似像素的机会也越大，但同时计算量也是成指数上升。在提出这个算法的文献中，这个区域是整幅图像！导致的结果是处理一幅512x512大小的图像，最少也得几分钟。

衡量像素相似度的方法有很多，最常用的是根据两个像素的亮度值的差的平方来估计。但因为有噪声的存在，单独的一个像素并不可靠。对此解决方法是，考虑它们的邻域，只有邻域相似度高才能说这两个像素的相似度高。衡量两个图像块的相似度最常用的方法是计算他们之间的欧氏距离：

$$
w(x,y) = {1 \over {n(x)}}\exp ({{\left\| {{\bf{V}}(x) - {\bf{V}}(y)} \right\|_{2,a}^2} \over {{h^2}}}).
$$

其中： n(x) 是一个归一化的因子，是所有权重的和，对每个权重除以该因子后，使得权重满足和为1的条件。 h>0 是滤波系数，控制指数函数的衰减从而改变欧氏距离的权重。 V(x) 和 V(y) 代表了像素 x 和像素 y 的邻域，这个邻域常称为块(Patch)邻域。块邻域一般要小于搜索区域。${\left\| {{\bf{V}}(x) - {\bf{V}}(y)} \right\|_{2,a}^2}$ 是两个邻域的高斯加权欧式距离。其中 a>0 是高斯核的标准差。在求欧式距离的时候，不同位置的像素的权重是不一样的，距离块的中心越近，权重越大，距离中心越远，权重越小，权重服从高斯分布。实际计算中考虑到计算量的问题，常常采用均匀分布的权重。

<center><img src="/img/post-ml/ray6.jpg" /></center>

如上图所示，p为去噪的点，因为q1和q2的邻域与p相似，所以权重w(p,q1)和w(p,q2)比较大，而邻域相差比较大的点q3的权重值w(p,q3)很小。如果用一幅图把所有点的权重表示出来，那就得到下面这些权重图：

![](/img/post-ml/ray7.jpg)

这6组图像中，左边是原图，中心的白色色块代表了像素 x 块邻域，右边是计算出来的权重 w(x,y) 图，权重范围从0（黑色）到1（白色）。这个块邻域在整幅图像中移动，计算图像中其他区域跟这个块的相似度，相似度越高，得到的权重越大。最后将这些相似的像素值根据归一化之后的权重加权求和，得到的就是去噪之后的图像了。

这个算法参数的选择也有讲究，一般而言，考虑到算法复杂度，搜索区域大概取21x21，相似度比较的块的可以取7x7。实际中，常常需要根据噪声来选取合适的参数。当高斯噪声的标准差 σ 越大时，为了使算法鲁棒性更好，需要增大块区域，块区域增加同样也需要增加搜索区域。同时，滤波系数 h 与 σ 正相关：h=kσ，当块变大时，k 需要适当减小。

NL-Means算法的复杂度跟图像的大小、颜色通道数、相似块的大小和搜索框的大小密切相关，设图像的大小为N×N，颜色通道数为Nc，块的大小为k×k，搜索框的大小为n×n，那么算法复杂度为：O(N2Nck2n2)。对512×512的彩色图像而言，设置k=7，n=21，OpenCV在使用了多线程的情况下，处理一幅图像所需要的时间需要几十秒。虽然有人不断基于这个算法进行改进、提速，但离实时处理还是比较远。

最后来看一下这个算法的去噪效果[3]：

![](/img/post-ml/ray8.jpg)

### BM3D算法

BM3D（Block-matching and 3D filtering，3维块匹配滤波）可以说是当前效果最好的算法之一。该算法的思想跟NL-Means有点类似，也是在图像中寻找相似块的方法进行滤波，但是相对于NL-Means要复杂得多，理解了NL-Means有助于理解BM3D算法。BM3D算法总共有两大步骤，分为基础估计（Step1）和最终估计（Step2）：

![](/img/post-ml/ray9.jpg)

在这两大步中，分别又有三小步：相似块分组（Grouping），协同滤波（Collaborative Filtering）和聚合（Aggregation）。上面的算法流程图已经比较好地将这一过程表示出来了，只需要稍加解释。

__Stpe1：基础估计__

(1) Grouping：有了NL-Means的基础，寻找相似块的过程很容易理解。首先在噪声图像中选择一些k×k 大小的参照块（考虑到算法复杂度，不用每个像素点都选参照块，通常隔3个像素为一个不长选取，复杂度降到1/9），在参照块的周围适当大小（n×n）的区域内进行搜索，寻找若干个差异度最小的块，并把这些块整合成一个3维的矩阵，整合的顺序对结果影响不大。同时，参照块自身也要整合进3维矩阵，且差异度为0。寻找相似块这一过程可以用一个公式来表示：

$$
G(P) = \{ Q:d(P,Q) \le {\tau ^{step1}}\} .
$$

d(P,Q)代表两个块之间的欧式距离。最终整合相似块获得的矩阵就是流程图Step1中左下角的蓝色R矩阵。

<center><img src="/img/post-ml/ray10.jpg" /></center>

(2) Collaborative Filtering：形成若干个三维的矩阵之后，首先将每个三维矩阵中的二维的块（即噪声图中的某个块）进行二维变换，可采用小波变换或DCT变换等，通常采用小波BIOR1.5。二维变换结束后，在矩阵的第三个维度进行一维变换，通常为阿达马变换（Hadamard Transform）。变换完成后对三维矩阵进行硬阈值处理，将小于阈值的系数置0，然后通过在第三维的一维反变换和二维反变换得到处理后的图像块。这一过程同样可以用一个公式来表达：

$$
Q(P) = T_{3Dhard}^{ - 1}(\gamma (T_{3Dhard}(Q(P)))).
$$

在这个公式中，二维变换和一维变换用一个T3Dhard 来表示。γ是一个阈值操作：

σ是噪声的标准差，代表噪声的强度。

(3) Aggregation：此时，每个二维块都是对去噪图像的估计。这一步分别将这些块融合到原来的位置，每个像素的灰度值通过每个对应位置的块的值加权平均，权重取决于置0的个数和噪声强度。


__Step2：最终估计__

(1) Grouping：第二步中的聚合过程与第一步类似，不同的是，这次将会得到两个三维数组：噪声图形成的三维矩阵Qbasic(P)和基础估计结果的三维矩阵Q(P)。

(2) Collaborative Filtering：两个三维矩阵都进行二维和一维变换，这里的二维变换通常采用DCT变换以得到更好的效果。用维纳滤波（Wiener Filtering）将噪声图形成的三维矩阵进行系数放缩，该系数通过基础估计的三维矩阵的值以及噪声强度得出。这一过程同样可以用一个公式来表达：

$$
Q(P) = T_{3Dwein}^{ - 1}(w_p \cdot {T_{3Dwein}}(Q(P))).
$$

在这个公式中，二维变换和一维变换用一个T3Dwein 来表示。wp是一个维纳滤波的系数：


σ是噪声的标准差，代表噪声的强度。
(3) Aggregation：与第一步中一样，这里也是将这些块融合到原来的位置，只是此时加权的权重取决于维纳滤波的系数和噪声强度。

经过最终估计之后，BM3D算法已经将原图的噪声显著地去除。可以来看一组结果：

![](/img/post-ml/ray2.jpg)

该算法的主要运算量还是在相似块的搜索与匹配上，在与NL-Means同样大小的相似块和搜索区域的情况下，BM3D的算法复杂度是要高于NL-Means的，应该大概在NL-Means的3倍左右。实时处理是跑不起来了。

## Noise2Noise

[Noise2Noise-Learning Image Restoration without Clean Data][i6]在ICML2018上，是图像领域的重要的论文。训练图像去噪不需要无噪的原图像。Noise2Noise的AI系统是基于深度学习算法创建的，并且已利用ImageNet数据集提供的50000张图片进行了强化锻炼。每一张训练图片都是由清晰的高质量原图上随机地加上噪点而创建的。计算机生成的图像和核磁共振（MRI）扫描成像也被用于训练Noise2Noise的AI系统。



如果我们接触过图像（信号）恢复中基于模型（重建）的算法，我们就知道：其难点和麻烦的地方，在于对似然函数（降质模型）和图像先验（稀疏、平滑等）的建模。而CNN很好地解决了这一问题，但需要大量的训练数据，通常是受损输入$x^i$和干净目标$y_i$，并且训练目标是最小化经验损失：

$$
\arg\min_{\theta} \sum_i L(f_{\theta}(\hat{x}_i), y_i) \tag{1}
$$

其中，$f_θ$是参数化的映射（a parametric family of mappings），例如CNN。

获取大量干净数据是很困难的。例如，为了获得无噪图像，我们需要长曝光；为了获得MRI图像的完整采样，图像中不能有动态目标等。

__点估计__

假设我们有一组温度采样数据(y1,y2,…)。我们希望在某种损失度量L下，得到温度估计值z（希望该损失最小）：

$$ \arg\min_z \mathbb{E}_y \{L(z,y)\} \tag{2} $$

如果采用L2损失，那么估计值就是观测值的算术平均：

$$
z = \mathbb{E}_y \{ y \} \tag{3}
$$

点估计带有一些统计平均的性质。比如，我们可以简单地对多点采样的温度取平均，得到最终的估计温度。

### 神经网络算法与点估计的关系

式1表达的是参数预测问题（不是简单地估计值，而是学习一个预测模型，服务千千万万的输入），式2是点估计问题，二者不是一个东西。理想状况下，网络的优化方式如下（提供准确的先验和似然）

$$
\arg\min_{\theta} \mathbb{E}_{(x,y)} \{ L(f_{\theta}(x), y) \} = \arg\min_{\theta} \mathbb{E}_x \{ \mathbb{E}_{(y | x)} \{ L(f_{\theta}(x), y) \} \} \tag{4}
$$

上式可以理解为：对于每一个样本$x_i$，都在执行一次点估计。可以理解为：根据观测点y，估计点$z=f_θ(x)$，而估计完成时，参数θ就可以根据z推出（或者说二者本质是一样的）。

当然，这种论证是很粗糙的，但提供给我们一个非常有用的见解。我们考虑超分辨问题：这是一个典型的病态问题，因为高频信息在采样过程中丢掉了，而同一张LR图像可以对应大量的HR图像。
借助上述点估计思想，我们不难理解：神经网络实际上是将这些大量的、可能的HR图像做了一个统计平均（点估计的特性），因此L2范数下超分辨图像常常被过度平滑。既然是统计平均，那么我们可以将干净图像y随意换成其他图像（信号），只要保证期望不变，那么也能得到我们想要的估计值$z=f_θ(x)$（式3），进而得到不变的参数θ（式4）！

换句话说，如果假设噪声零均值（或保证期望仍然是无噪图像的期望），那么我们就可以让神经网络的输入和监督都是有噪图像，学习的参数是一样的！

$$
\mathbb{E} \{ \hat{y}_i | \hat{x}_i \} = y = \mathbb{E} \{ y_i | \hat{x}_i \} \tag{5}
$$

其中，$x^i$是有噪图像，$y^i$也是有噪图像（$y_i$不一定要和$x_i$相同），y就是目标干净图像。



## 参考资料

* [Tungsten 基于物理的渲染器][i7] 
* [几何交叉库 embree][i1]
* [峰值信噪比, PSNR, 百科][i4]
* [Learning Image Restoration without Clean Data, arxiv][i6]
* [Learning Image Restoration without Clean Data, pytorch, github][i2]
* [Learning Image Restoration without Clean Data, tensorflow, github][i5]


[i1]: https://www.embree.org/
[i2]: https://github.com/joeylitalien/noise2noise-pytorch
[i3]: https://www.cnblogs.com/graphics/archive/2010/08/09/1795348.html
[i4]: https://baike.baidu.com/item/psnr/2925132?fr=aladdin
[i5]: https://github.com/NVlabs/noise2noise
[i6]: https://arxiv.org/abs/1803.04189
[i7]: https://github.com/tunabrain/tungsten
[i8]: https://benedikt-bitterli.me/nfor/denoising-data.zip